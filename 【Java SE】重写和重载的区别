重载：
重载是一个类中多态性的一种表现。 在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。
例如：

public class Father { 
    public static void main(String[] args) { 
        Father s = new Father();
        s.sayHello();
        s.sayHello("wintershii");
 
    }
 
    public void sayHello() {
        System.out.println("Hello");
    }
 
    public void sayHello(String name) {
        System.out.println("Hello" + " " + name);
    }
}

总结：
1.重载是一个类中多态性的一种表现
2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)
3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准 

重写:
从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。
例如： 

public class Father {
 
    public static void main(String[] args) { 
        Son s = new Son();
        s.sayHello();
    }
 
    public void sayHello() {
        System.out.println("father Hello");
    }
}
 
class Son extends Father{
    @Override  //重写标志
    public void sayHello() {  
        System.out.println("son hello  ");
    }
 
}

 总结：
1.发生在父类与子类之间
2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同
3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)
4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 

区别：
重载实现于一个类中;重写实现于子类中。

重载(Overload)：是一个类中多态性的一种表现，指同一个类中不同的函数使用相同的方法名，但是方法的参数个数或类型不同。可以有不同的返回类型;可以有不同的访问修饰符;可以抛出不同的异常。调用的时候根据方法的参数来区别不同的方法。

重写（Override): 是父类与子类之间的多态性，是子类对父类方法的重新实现。方法名和参数与父类一样，子类与父类方法体内容不一样。子类返回的类型必须与父类保持一致；子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public>protected>default>private）；子类重写方法一定不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常。

面试时，问：重载和重写的区别？
答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。 

 
————————————————
版权声明：本文为CSDN博主「嘎嘎烤鸭」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_65601072/article/details/126931177
